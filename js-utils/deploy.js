
/*
 *  =================================================================
 *
 *    16.06.24   <--  Date of Last Modification.
 *                   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *  -----------------------------------------------------------------
 *
 *  **** Module  :  js-utils/deploy.js
 *       ~~~~~~~~~
 *  **** Project :  jsCoFE - javascript-based Cloud Front End
 *       ~~~~~~~~~
 *  **** Content :  Code minimiser
 *       ~~~~~~~~~
 *
 *  (C) E. Krissinel, A. Lebedev 2020-2024
 *
 *  =================================================================
 *
 * Invocation:
 *
 *    node js-utils/deploy.js {configFile.json | template} [--no-strict|--strict]
 *
 * where "configFile.json" is path to JSON-formatted configuration file of
 * jsCoFE, containing configurations for the Front End server. Alternatively,
 * "template" file can be used, for example, html bootstrap page or any
 * text file, containing lists of .css and .js files in quotes, e.g.,
 *
 *    "path/file1.css"
 *    "path/file2.css"
 *    "path/file3.css"
 *    "path/file1.js"
 *    "path/file2.js"
 *    "path/file3.js"
 *
 * If optional --no-strict parameter is provided (must be the last one in
 * the command line), 'use strict'; sentences will be deleted from the code.
 * This is recommended for the deployment on the production server, and not
 * recommended for developer's and test servers. This is the default option;
 * use --strict to enforce strict checks at run time.
 *
 * How it works if jsCoFE .json configuration file is provided:
 *
 *  "deploy.js" reads all .css and .js files mentioned in html bootstrap file
 *  specified in "configFile.json" and minimizes them to files base.min.css and
 *  base.min.js in the bootstrap directory. Here, "base" is the base name of
 *  the bootrstrap html. In addition, "deploy.js" creates new bootstrap html
 *  file "base.min.html" with urls to the new minimised files.
 *
 *  For example, if bootstrap html file path in "configFile.json" is
 *  "bootstrap/jscofe.html", then the following files are created:
 *         bootrstap/jscofe.min.css
 *         bootrstap/jscofe.min.js
 *         bootrstap/jscofe.min.js.map
 *         bootrstap/jscofe.min.html
 *  and the latter may be substituted in "configFile".
 *
 *  NOTE 1: if bootstrap html file path in "configFile" follows the following
 *  pattern:  "bootstrap/base.min.html", then the original html file:
 *  "bootstrap/base.html" MUST BE in the bootstrap directory. This allows
 *  multiple regeneration of minimised files without changes in "configFile".
 *
 *  NOTE 2: for minimised setup to work properly, the following items must be
 *  placed in the bootstrap directory:
 *     images           - copy of the "images" directory from js-lib/jquery-ui
 *     32px.png, 40pxpng and throbber.gif  - copied from js-lib/jstree/themes/default
 *
 *  Typical bootstrap directory with minimised setup should look like
 *
 *   -rw-r--r--  1 eugene  staff     3121 19 Sep 17:42 32px.png
 *   -rw-r--r--  1 eugene  staff     1880 19 Sep 17:42 40px.png
 *   -rwxr-xr-x  1 eugene  staff     2987 21 Apr 18:32 authend.html
 *   drwxr-xr-x  8 eugene  staff      256 19 Sep 17:37 images
 *   -rwxr-xr-x  1 eugene  staff    16013 19 Sep 15:24 jscofe.html
 *   -rw-r--r--  1 eugene  staff    98539 19 Sep 17:30 jscofe.min.css
 *   -rw-r--r--  1 eugene  staff     2067 19 Sep 17:30 jscofe.min.html
 *   -rw-r--r--  1 eugene  staff  1646972 19 Sep 17:30 jscofe.min.js
 *   -rw-r--r--  1 eugene  staff  1812884 19 Sep 17:30 jscofe.min.js.map
 *   -rw-r--r--  1 eugene  staff     1720 19 Sep 17:42 throbber.gif
 *
 *  where all .min.* files are regenerated by "deploy.js" as necessary.
 *
 *
 * How it works if a template file is provided:
 *
 *  "deploy.js" reads all .css and .js files mentioned in the provided template
 *  file and minimizes them to files base.min.css and base.min.js in the
 *  template file's directory. Here, "base" is the base name of the template
 *  file. In this mode, html file with minimised .css and .js is not generated
 *  and should be created separately.
 *
 */

//  load system modules
const path     = require('path');
const csso     = require('csso');
const UglifyJS = require("uglify-js");

//  load application modules
const conf     = require('../js-server/server.configuration');
const utils    = require('../js-server/server.utils');
const cmd      = require('../js-common/common.commands');

//  prepare log
const log = require('../js-server/server.log').newLog(25);


// ==========================================================================

const now   = new Date();
const day   = String(now.getDate()).padStart(2, '0');
const month = String(now.getMonth() + 1).padStart(2, '0'); // getMonth() returns 0-11, so add 1
const year  = now.getFullYear();
const stamp = cmd.appName() + ' v.' + cmd.appVersion() +
              ' generated ' + `${day}-${month}-${year}`;


function change_extention ( fpath,new_ext )  {
  return path.join ( path.dirname(fpath),
                     path.basename(fpath,path.extname(fpath)) + new_ext );
}

if (
    (process.argv.length<3) ||
    ((process.argv.length==4) && (process.argv[3]!='--no-strict')
                              && (process.argv[3]!='--strict'))
   )  {
  let usage = 'Usage: ' + process.argv[0] + ' ' + process.argv[1] +
                          ' config.json [--no-strict|--strict]';
  log.error ( 1,'Incorrect command line. Stop.' );
  log.error ( 1,usage );
  process.exit(1);
}


// ---------------------------------------------------------------------------
//  Analyse input file

conf.setPythonVersion ( 'x.x.x' );  // do not check python

let cfgfpath  = process.argv[2];
let feConfig  = null;
let inpfpath  = '';
let inpfdata  = '';
let no_strict = (process.argv.length<4) || (process.argv[3]=='--no-strict');
                                                     // syntax is checked above

if (cfgfpath.endsWith('.json'))  {

  let msg = conf.readConfiguration ( cfgfpath,'FE' );
  if (msg)  {
    log.error ( 2,'desktop configuration failed. Stop.' );
    log.error ( 2,msg );
    process.exit(2);
  }

  utils.configureCache ( 0 );

  feConfig = conf.getFEConfig();
  inpfpath = feConfig.bootstrapHTML;
  if (inpfpath.endsWith('.min.html'))
    inpfpath = inpfpath.substr(0,inpfpath.lastIndexOf('.min.html')) + '.html';

  log.standard ( 1,'bootstrap html path: ' + inpfpath );

  inpfdata = utils.readString ( inpfpath );
  if (!inpfdata)  {
    log.error ( 3,'bootrtrap html file not found at ' + inpfpath );
    process.exit(3);
  }

} else  {

  utils.configureCache ( 0 );

  let inpfpath = cfgfpath;
  log.standard ( 3,'template file path: ' + inpfpath );

  inpfdata = utils.readString ( inpfpath );
  if (!inpfdata)  {
    log.error ( 4,'template file not found at ' + inpfpath );
    process.exit(4);
  }

}

// remove comments
inpfdata = inpfdata.replace ( /<!--[\s\S]*?-->/g,'' );

let inpfdir  = path.dirname ( inpfpath );
let basename = path.parse(inpfpath).name;

// ---------------------------------------------------------------------------
//  Fetch lists of CSS and JS files

let filelist = inpfdata.split('"');
let csslist  = [];
let jslist   = [];

for (let i=0;i<filelist.length;i++)
  if (filelist[i].endsWith('.css'))
    csslist.push ( filelist[i] );
  else if (filelist[i].endsWith('.js'))
    jslist.push ( filelist[i] );

let indent = '\n                                      ';
log.standard ( 2,'css list (' + csslist.length + '):' + indent + csslist.join(indent) );
log.standard ( 3,'js list ('  + jslist.length + '):'  + indent + jslist.join(indent) );


// ---------------------------------------------------------------------------
//  Minify CSS

let data_css = '';
for (let i=0;i<csslist.length;i++)  {
  let css = utils.readString ( csslist[i] );
  if (css)  {
    // remove comments
    css = css.replace ( /\/\*[\s\S]*?\*\//g, '' );
    data_css += css + '\n\n';
  } else  {
    log.error ( 5,'css file not found at ' + csslist[i] );
    process.exit(5);
  }
}

let csspath = '';
if (data_css)  {

  let result_css = csso.minify ( data_css, {
    restructure : false,  // don't change CSS structure, i.e. don't merge declarations, rulesets etc
    debug       : true    // show additional debug information:
                          // true or number from 1 to 3 (greater number - more details)
    //filename    : 'path/to/my.css', // will be added to source map as reference to source file
    //sourceMap   : true             // generate source map
  });

  if (result_css.css)  {

    result_css.css = '/* ' + stamp + ' */\n' + result_css.css;

    csspath = path.join ( inpfdir,basename + '.min.css' );
    if (utils.writeString(csspath,result_css.css))  {
      log.standard ( 12,'merged css written to '  + csspath );
    } else {
      log.error    ( 12,'cannot write ' + csspath );
      process.exit ( 12 );
    }

  } else
    log.standard ( 11,'failed to minigify css' );

}


// ---------------------------------------------------------------------------
//  Minify JS

if (no_strict)
      log.standard ( 13,'remove strict checks runtime' );
else  log.standard ( 13,'keep strict checks runtime' );

let jscode = {};
for (let i=0;i<jslist.length;i++)  {
  let jsdata = utils.readString ( jslist[i] );
  if (jsdata)  {
    let len0 = jsdata.length;
    if (no_strict)  // remove all occurencies
          jscode[jslist[i]] = jsdata.split('\'use strict\';').join('');
    else  jscode[jslist[i]] = jsdata;
    if (jscode[jslist[i]].length!=len0)
      log.standard ( 14,'destricted: ' + jslist[i] );
  } else  {
    log.error ( 20,'js file not found at ' + jslist[i] );
    process.exit(20);
  }
}

let result = UglifyJS.minify ( jscode,{
  warnings  : false,
  sourceMap : {
    filename : basename + '.min.js',
    url      : basename + '.min.js.map'
  }
});


if (result.warnings)  {
  log.standard ( 21,'warnings:' );
  console.log(result.warnings); // runtime error, or `undefined` if no error
} else
  log.standard ( 21,'no warnings generated' );


let jspath = '';

if (result.error)  {

  log.error ( 22,'js errors:' );
  console.log(result.error); // runtime error, or `undefined` if no error
  process.exit(22);

} else if (result.code)  {

  jspath = path.join ( inpfdir,basename + '.min.js' );

  result.code = '/* ' + stamp + ' */\n' + result.code;

  if (utils.writeString(jspath,result.code))  {
    log.standard ( 23,'minimsed/merged js written to '  + jspath );
  } else  {
    log.error    ( 23,'cannot write ' + jspath );
    process.exit ( 23 );
  }

  if (result.map)  {
    let mappath = path.join ( inpfdir,basename + '.min.js.map' );
    if (utils.writeString(mappath,result.map))
      log.standard ( 24,'merged js map written to '  + mappath );
    else  {
      log.error    ( 24,'cannot write ' + mappath );
      process.exit ( 24 );
    }
  }

} else
  log.standard ( 25,'minimised/merged js was not generated' );

if (result.code && feConfig)  {

  let inpfmin   = [];
  let inpflines = inpfdata.split(/\r?\n/);

  let css_key = -1;
  if (csspath)
    css_key = 0;

  let js_key = -1;
  if (jspath)
    js_key = 0

  for (let i=0;i<inpflines.length;i++)  {
    if (i==1)
      inpfmin.push ( '<!-- ' + stamp + ' -->' );
    if ((css_key>=0) && (inpflines[i].indexOf('.css"')>=0))  {
      if (!css_key)  {
        css_key = 1;
        inpfmin.push ( '  <link rel="stylesheet" type="text/css" href="' + csspath + '"/>' );
      }
    } else if ((js_key>=0) && (inpflines[i].indexOf('.js"')>=0))  {
      if (!js_key)  {
        js_key = 1;
        inpfmin.push ( '  <script type="text/javascript" src="' + jspath + '"></script>' );
      }
    } else if (inpflines[i].trim())
      inpfmin.push ( inpflines[i] );
  }

  let inpfpath_min = change_extention ( inpfpath,'.min.html' );
  if (utils.writeString(inpfpath_min,inpfmin.join('\n')))
    log.standard ( 26,'modified html bootstrap written in ' + inpfpath_min );
  else  {
    log.error    ( 26,'cannot write modified html bootstrap at ' + inpfpath_min );
    process.exit ( 26 );
  }

  process.exit(0);

}
