.. _custom_workflows:

=======================================
Custom (user-created) project workflows
=======================================

CCP4 Cloud projects can be developed automatically, using one of pre-defined
:ref:`automatic workflows <workflows_guide>`, as well as *custom workflows*,
defined by user.

.. _custom_workflows_use:

--------------------------------------------------
What are custom workflows and how one can use them
--------------------------------------------------

Custom workflow is a script (*WScript*) describing tasks that need to be 
performed and the order of their invocation, *i.e.*, the workflow algorithm.
The script is placed in a plain text file with extension ``.wscript``,
which can be created by most text editors, such as *vim*, *nano*, *notepad*
(Windows), *TextEdit* (Mac) and similar. Make sure that you save file as
"plain text" when using advanced editors such as *MS Word*, *Libre Office*
(not recommended).

Custom workflow can be started in one of 3 ways:

* Import ``.wscript`` file with other needed files, such as ``.mtz``
  (reflections, phases), ``.pdb``, ``.mmcif`` (structure models),
  ``.cif`` (ligand descriptions), ``.lib`` (restraint libraries),
  ``.seq``, in a *single* import task. After importing, the task will
  start workflow automatically if *WScript* is correct and all necessary 
  data files are provided 

* Add ``.wscript`` files to the set of data files in
  :ref:`CloudRun command file <cloudrun>` (use generic :ref:`FILE <cloudrun_FILE>`
  keyword), choose :ref:`import <cloudrun_TASK>` task and execute the
  ``CloudRun`` utility. All file will be uploaded to CCP4 Cloud, project
  created and workflow started automatically

* Add *WScript* to the *My Workflows* list in the *Workflows* tab of the
  *Task List*, after which it can be used as any other task in the
  system.


-------------------------------------
Writing the Workflow script (WScript)
-------------------------------------

The main idea behind workflows is to automate operations when the same
project (or branch of a project) needs to be repeated many (100s) times with 
different input data, and **WScript** is limited to that purpose.

The easiest way to create a **WScript** file is through using **Workflow Creator**
in CCP4 Cloud. Login in your account and open **Task List** in any project.
Then open tab **Workflows**, scroll it to section **My Workflows** in the end
and push button **Add workflow**. This will launch **Workflow Creator** window
with a template script loaded. It makes a good sense to save the newly created
workflow in your personal library, therefore give it a unique *Workflow ID* on 
top of the dialog window. For easier workflow identification in **My Workflows** 
library, you may also change the colour of the workflow icon – simply click on 
it and choose from available options. Now you can save the script – it will
appear in the **My Workflows** section of the **Task List**. You can run it as
any other task now, but doing so will result in an empty **Job Dialog**, because
we only saved a template, which does nothing.

Let's give it a useful content now. Click on **Edit** button on the right from 
the just created workflow in **My Workflows**, this opens **Workflow Creator**
again, with the previous content looking something like this: ::

    #
    # * THIS IS A WORKFLOW SCRIPT TEMPLATE
    # * DO NOT ASSUME THAT IT IS FUNCTIONAL WITHOUT EDITING
    # * CONSULT DOCUMENTATION
    #

    # -----------------------------------------------------
    # Give Workflow Title here
    # -----------------------------------------------------
    # Sun Dec 31 2023
    #

    VERSION  1.0    # script version for backward compatibility
    DEBUG    OFF    # ON/OFF
    COMMENTS ON     # ON/OFF
    WID      d-imp  # (optional) workflow ID for import mode

    # ==========================================================================
    # Workflow header -- EDIT AS NECESSARY

    # General workflow descriptors
    NAME     my workflow             # to show in Job Tree
    ONAME    my_wflow                # to use for naming output files
    TITLE    My Workflow Title       # to display in Task List
    DESC     my workflow description # to display in Task List
    ICON     Maraschino              # (optional) workflow icon colour
    KEYWORDS my own workflow         # for using in A-Z keyword search

    ALLOW_UPLOAD       # create file upload widgets if started from project root

    # ==========================================================================
    # Input data section. List all data required, "!" specifies mandatory items.
    # Edit template statements below as necessary:

    # !DATA HKL UNMERGED TYPES anomalous
    # !DATA XYZ          TYPES protein dna rna
    # DATA LIBRARY
    # DATA SEQ           TYPES protein dna rna
    # DATA LIGAND

    # ==========================================================================
    # Workflow parameters section. List all parameters required, "!" specifies
    # mandatory items. Edit template statements below as necessary:

    # !PAR_INTEGER nCycles  # variable name to be used in workflow's expressions
    #    LABEL     Number of cycles
    #    TOOLTIP   Number of refiniement cycles
    #    IWIDTH    40        # (optional) input field width is set to 40 pixels
    #    RANGE     0 50      # (optional) allowed min/max values
    #    DEFAULT   10        # (optional) default integer value

    # PAR_REAL     resHigh   # variable name to be used in workflow's expressions
    #    LABEL     High resolution cut-off (&Aring;)
    #    TOOLTIP   High resolution cut-off, angstrom
    #    IWIDTH    40        # input field width is set to 40 pixels
    #    RANGE     0.1 5.0   # allowed min/max values
    #    DEFAULT   1.5       # default real value

    # !PAR_STRING  atomType  # variable name to be used in workflow's expressions
    #    LABEL     Anomalous scatterer
    #    TOOLTIP   Expected main anomalous scatterer
    #    IWIDTH    20        # input field width is set to 20 pixels
    #    MAXLENGTH 2         # (optional) maximum 2 characters
    #    DEFAULT   Se        # (optional) default string value "Se"

    # PAR_CHECK    reqValReport # variable name to be used in workflow's expressions
    #    LABEL     Request PDB Validation Report
    #    TOOLTIP   Check if deposition files should be prepared and PDB validation report obtained
    #    DEFAULT   Unchecked

    # !PAR_COMBO   useBFactors # variable name to be used in workflow's expressions
    #    LABEL     Use isotropic B-factors
    #    TOOLTIP   B-factor mode for refinement
    #    IWIDTH    60        # input field width is set to 60 pixels
    #    OPTION    none  Select from list  # value "none" text "Select from list" 
    #    OPTION    yes   Yes               # value "yes"  text "Yes"
    #    OPTION    no    No                # value "no"  text  "No"
    #    DEFAULT   none                    # default string value "none"

    # ==========================================================================
    # Workflow run body

In **WScript** lines, everything on the right from the hash "#" sign is a comment
and may be safely deleted. Perhaps you may want to delete first few lines from
the template, but in general, the more comments you make in the script, the more 
understandable and maintainable it is. You can use spaces to your aesthetic 
preferences; where there must be a space separator, any number of spaces can be
used. 

**WScript** is based on single-line statements, containing keywords and values.
Keywords, which normally start **WScript** statements, are case-insensitive.
Values, on contrary, should be specified with respect to upper/lower case. Full
list of keywords is given in the end of this document.

We will create new workflow in several steps now.

~~~~~~~~~~~~~~~~~~
Simple MR Workflow
~~~~~~~~~~~~~~~~~~

As first example, let's write a simple workflow, which takes reflection data,
structure template, sequence and solves structure with Molecular Replacement
using Molrep.

Firstly, remove unnecessary lines and put a reasonable annotation in the
header section of the **WScript** file, so that it starts with this
workflow header: ::

    #
    # -----------------------------------------------------
    # Molecular Replacement with Molrep
    # -----------------------------------------------------
    # Sun Dec 31 2023
    #

    VERSION  1.0    # script version for backward compatibility
    DEBUG    OFF    # ON/OFF
    COMMENTS ON     # ON/OFF

    # ==========================================================================
    # Workflow header

    # General workflow descriptors
    NAME     molrep workflow         # to show in Job Tree
    ONAME    mrp_wflow               # to use for naming output files
    TITLE    Molrep-based Workflow   # to display in Task List
    DESC     takes HKL, XYZ and SEQ and solves structure with Molrep
    ICON     Maraschino              # (optional) workflow icon colour
    KEYWORDS molrep workflow         # for using in A-Z keyword search

    ALLOW_UPLOAD       # create file upload widgets if started from project root

You may save the workflow now and check how its description changed in
**My Workflows** list. Re-open it again by pushing the relevant **Edit** button.

Secondly, specify data, which workflow will use, in **WScript**'s' input data
section (just append these statements to the script): ::

    # ==========================================================================
    # Input data section. List all data required, "!" specifies mandatory items.

    !DATA HKL
    !DATA XYZ  TYPES protein
    !DATA SEQ  TYPES protein

These statements mean that the workflow requires 3 mandatory items: reflection 
data (HKL), search model (XYZ, must be protein chain(s)) and sequence (SEQ, 
also of aminoacid type). In order to understand what these statements do, save 
the script and create a new task with it from the root of your project – you
should see input fields for data files. To check further, run Cloud's 
**File Import** task and import all needed files, then append your workflow as
the next task – you should see selectors for imported data. You can even run 
the workflows now; it will fail immediately though because we did not specify 
any tasks in the **WScript** file yet.

We now want to make a sequence of at least 5 tasks:

- prepare MR model
- define ASU
- run Molrep
- re-build model with, e.g., Buccaneer
- refine with Refmac

Re-open molrep workflow script in **Workflow Cretor** again. In the bottom of 
the dialog window, click button **Add task** and select *"Model Preparation XYZ"*
in the combobox found in the header. This populates the dialog window with
default task options like in original task interfaces. Choose options that you
want to change, set their values, and push **Add to workflow** button. This
will append the following construct: ::

    @MODELPREPXYZ
        RUN ModelPrepXYZ

to the end of the script if you did not change anything in task parameters.
If a non-default parameter value were chosen, *e.g.*, if you changed
*"Modification protocol"* for *"PDB Clip"*, then the construct would
look slightly different: ::

    @MODELPREPXYZ
        PARAMETER MODIFICATION_SEL D  # Modification protocol
        RUN ModelPrepXYZ

These examples give an idea of how CCP4 Cloud tasks are described in custom 
workflows. Each task is represented by a block of lines, which starts with
*RUN NAME* and finishes with *RUN* statement. *RUN NAME* must be a unique
alphanumeric identifier starting with *"@"* symbol. Other lines between
*RUN NAME* and *RUN* statements may contain values for task parameters,
and only non-default parameters should be specified for brevity. See more
details in the :ref:`wscript_reference` below.

Similarly to the *"Model Preparation XYZ"* task, you can now add 
*"ASU Definition"*, *"Molrep"*, *"Buccaneer"* and *"Refmac"* tasks to the
workflow, in that order. The resulting **WScript** will look like
the following: ::

    #
    # -----------------------------------------------------
    # Molecular Replacement with Molrep
    # -----------------------------------------------------
    # Sun Dec 31 2023
    #

    VERSION  1.0    # script version for backward compatibility
    DEBUG    OFF    # ON/OFF
    COMMENTS ON     # ON/OFF

    # ==========================================================================
    # Workflow header

    # General workflow descriptors
    NAME     molrep workflow         # to show in Job Tree
    ONAME    mrp_wflow               # to use for naming output files
    TITLE    Molrep-based Workflow   # to display in Task List
    DESC     takes HKL, XYZ and SEQ and solves structure with Molrep
    ICON     Maraschino              # (optional) workflow icon colour
    KEYWORDS molrep workflow         # for using in A-Z keyword search

    ALLOW_UPLOAD       # create file upload widgets if started from project root

    # ==========================================================================
    # Input data section. List all data required, "!" specifies mandatory items.

    !DATA HKL
    !DATA XYZ  TYPES protein
    !DATA SEQ  TYPES protein

    # ==========================================================================
    # Workflow parameters section. List all parameters required, "!" specifies
    # mandatory items.

    # ==========================================================================
    # Workflow run body

    @MODELPREPXYZ
        RUN ModelPrepXYZ
    #

    @ASUDEF
        RUN ASUDef
    #

    @MOLREP
        RUN Molrep
    #

    @BUCCANEER
        RUN Buccaneer
    #

    @REFMAC
        RUN Refmac
    #

This makes a completely functional workflow, which you can run now by any of
the three methods described in :ref:`custom_workflows_use` (you need to
copy-paste **WScript** from **Workflow Creator** into external file with 
``.wscript`` extension for using it with the **Import** task or **CloudRun**
utility).

.. note::
   Unlike in manually-developed CCP4 Cloud projects, where a user cannot
   create a task if there is no suitable data for it, workflows do not
   check or control that task order is correct from the data flow point of 
   view. Therefore, you should have a good understanding of task order
   suitable for your purposes, or, better, take it from a manually developed
   project representing your workflow in design.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Conditional statements and other advanced operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

At the moment, our molrep workflow is quite straightforward in respect to its 
input data and algorithm. We may wish to make it more flexible. For example,
it would be good if can take both merged and unmerged reflection data on input,
optimize refinement parameters and, optionally, prepare file for PDB deposition
from best results achieved.

**Conditions based on availability of data**

Let's start from optional unmerged reflections input. We can instruct the
workflow to accept both merged and unmerged reflections by modifying the
corresponding ``DATA`` statement as below: ::

    !DATA HKL UNMERGED
    !DATA XYZ  TYPES protein
    !DATA SEQ  TYPES protein

Now we need scale and merge unmerged reflections with *"Aimless"* task, which
should be run before merged reflections are used, *i.e.*, before 
*"ASU Definition"* or even *"Model Preparation XYZ"*. To do that, open
workflow's **WScript** in **Workflow Creator**, place cursor on line just
above the ``@MODELPREPXYZ`` line and push **Insert task** button, then select 
*"Aimless"* task in new window and push **Insert in workflow** button. This
should modify the beginning of workflow body as below: ::

    # ==========================================================================
    # Workflow run body

    @AIMLESS
        DATA      ds0  unmerged
        RUN Aimless
    #

    @MODELPREPXYZ
        RUN ModelPrepXYZ
    #

    @ASUDEF
        RUN ASUDef
    #

This fragment will work fine if workflow receives unmerged reflections on input. 
However, if, instead, already scaled and merged reflections are supplied,
the *"Aimless"* task will fail and workflow stop. In order to skip invocation
of *"Aimless"* task if no data is available, put ``IFDATA`` statement into
task's description: ::

    @AIMLESS
        IFDATA    unmerged
        DATA      ds0  unmerged
        RUN Aimless
    #

.. note::
   in ``IFDATA`` statement, ``unmerged`` must be in lower case.

Now, the workflow will work with both merged and unmerged reflection data. If a
task needs to be run when data *is not* available, use ``IFNODATA`` instead.
For example, an equivalent (but less obvious) solution could be ::

    @AIMLESS
        IFNODATA  hkl
        DATA      ds0  unmerged
        RUN Aimless
    #

.. note::
   data names in ``IFDATA`` and ``IFNODATA`` statements are given by the
   lower-case versions of the corresponding data types used in ``DATA``
   statements, i.e., ``hkl``, ``unmerged``, ``xyz``, ``seq`` and so on.
   See :ref:`wscript_reference`  for details.

**Looping and Branching**

Sometimes, a task needs to be run with same data but varying parameters. In 
CCP4 Cloud terms, this is equivalent to cloning task with suitable modification
of parameter(s) of interest. For example, imagine that you wish to repeat
*"Refmac"* task with suggested parameters until no suggestions are generated or
number of runs exceeds a certain number (let's say, 5). The following fragment
gives an idea of how this may be programmed in **WScript**: ::

    # Initialise loop control parameters

    let iter   = 1     # iteration serial number
    let iter0  = 0     # iteration number of result with the lowest Rfree
    let Rfree0 = 1.0   # the lowest Rfree achieved

    @REFINE-OPT[iter]  # [iter] modifies the RUN NAME implicitly to make it unique
        USE_SUGGESTED_PARAMETERS   # use suggested parameters or defaults if none
        RUN       Refmac

    # capture iteration number with the lowest Rfree achieved
    let iter0 = iter; Rfree0 = Rfree  if  Rfree<Rfree0
    let iter  = iter + 1

    # keep iterating if conditions are met and pass otherwise
    repeat @REFINE-OPT while suggested>0 and iter<5 

    # continue further down from iteration with the lowest Rfree
    branch @REFINE-OPT[iter0]

In this fragment, workflow allocates 3 variables ``iter``, ``iter0`` and
``Rfree0`` and uses predefined variables ``Rfree`` (achieved *R_free*) and
``suggested`` (the number of suggested changes to *Refmac* parameters).
You may replace ``@REFMAC`` run construct with this entire fragment in our
molrep workflow and re-run it to see the result.

The ``branch`` statement specifies results from which particular task will be 
taken for further processing. In this example, results with lowest *R_free*
will be chosen. To see this, append another task, such as 
*"PDB Validation Report"* to the workflow and re-run it.


**Workflow parameters**

Supose no that we want to introduce workflows parameters, which a user could
manioulate with as in any other task. For example, let user to set a
resolution cut-off in *Aimless* and decide whether to run *Buccaneer* task.
For this, add input of real-number parameter and a checkbox in
:ref:`wscript_reference_input_parameters`: ::

    # ==========================================================================
    # Workflow parameters section. List all parameters required, "!" specifies
    # mandatory items.

    PAR_REAL      resHigh   # variable name to be used in workflow's expressions
        LABEL     High resolution cut-off (&Aring;)
        TOOLTIP   High resolution cut-off, angstrom
        IWIDTH    40        # input field width is set to 40 pixels
        RANGE     0.1 5.0   # allowed min/max values
        DEFAULT   1.5       # default value

    PAR_CHECK     runBuccaneer # variable name to be used in workflow's expressions
        LABEL     Re-build model
        TOOLTIP   Check if phased model should be re-built
        DEFAULT   Checked

Save **WScript**, create a new molrep workflow task and check how graphical
widgets for parameters look like.

When workflow is started, it assigns input parameters (either given by user or
read from *DEFAULT* fields) to internal variables specified in *PAR_XXX* 
statements. In the above example, two variables: *resHigh* and *runBuccaneer*
will be created for high-resolution cutoff (real) and flag for running
*Buccaneer* (boolean *True/False*), respectively. In order to use these flags,
remove *Aimless* task from the workflow and re-insert it in the same place
with **Workflow Creator**. When selecting *Aimless* in the task menu, specify
a non-default value for the high-resolution cut-off, for example, 1.4A. This
will give code fragment as follows: ::

    @AIMLESS
        DATA      ds0  unmerged
        PARAMETER RESO_HIGH 1.4  # high resolution cut-off (&Aring;)
        RUN Aimless

Now specify place the internal variable from the resolution cut-off widget 
instead of "1.4" and restore the ``IFDATA`` statement: ::

    @AIMLESS
        IFDATA    unmerged
        DATA      ds0  unmerged
        PARAMETER RESO_HIGH resHigh  # high resolution cut-off (&Aring;)
        RUN Aimless
    #

.. note::
   Where a variable is used, any function can be used as well. For example,
   one can put ``2*resHigh``, ``max(1.5,resHigh)`` and similar expressions 
   instead of ``resHigh`` in the above **WScript** fragment.

As for the *Buccaneer*, we need simply to indicate that the task should be
run if ``runBuccaneer`` is ``True``: ::

    @BUCCANEER
        IF runBuccaneer
        RUN Buccaneer

The final **WScript** for our molrep workflow reads as follows: ::

    #
    # -----------------------------------------------------
    # Molecular Replacement with Molrep
    # -----------------------------------------------------
    # Sun Dec 31 2023
    #

    VERSION  1.0    # script version for backward compatibility
    DEBUG    OFF    # ON/OFF
    COMMENTS ON     # ON/OFF

    # ==========================================================================
    # Workflow header

    # General workflow descriptors
    NAME     molrep workflow         # to show in Job Tree
    ONAME    mrp_wflow               # to use for naming output files
    TITLE    Molrep-based Workflow   # to display in Task List
    DESC     takes HKL, XYZ and SEQ and solves structure with Molrep # to display in Task List
    ICON     Maraschino              # (optional) workflow icon colour
    KEYWORDS molrep workflow         # for using in A-Z keyword search

    ALLOW_UPLOAD       # create file upload widgets if started from project root

    # ==========================================================================
    # Input data section. List all data required, "!" specifies mandatory items.

    !DATA HKL
    !DATA XYZ  TYPES protein
    !DATA SEQ  TYPES protein

    # ==========================================================================
    # Workflow parameters section. List all parameters required, "!" specifies
    # mandatory items.

    PAR_REAL     resHigh   # variable name to be used in workflow's expressions
        LABEL     High resolution cut-off (&Aring;)
        TOOLTIP   High resolution cut-off, angstrom
        IWIDTH    40        # input field width is set to 40 pixels
        RANGE     0.1 5.0   # allowed min/max values
        DEFAULT   1.5       # default real value

    PAR_CHECK     runBuccaneer # variable name to be used in workflow's expressions
        LABEL     Re-build model
        TOOLTIP   Check if phased model should be re-built
        DEFAULT   Checked

    # ==========================================================================
    # Workflow run body

    @AIMLESS
        IFDATA    unmerged
        DATA      ds0  unmerged
        PARAMETER RESO_HIGH resHigh  # high resolution cut-off (&Aring;)
        RUN Aimless
    #

    @MODELPREPXYZ
        RUN ModelPrepXYZ
    #

    @ASUDEF
        RUN ASUDef
    #

    @MOLREP
        RUN Molrep
    #

    @BUCCANEER
        IF runBuccaneer
        RUN Buccaneer
    #

    # Initialise loop control parameters

    let iter   = 1     # iteration serial number
    let iter0  = 0     # iteration number of result with the lowest Rfree
    let Rfree0 = 1.0   # the lowest Rfree achieved

    @REFINE-OPT[iter]  # [iter] modifies the RUN NAME implicitly to make it unique
        USE_SUGGESTED_PARAMETERS   # use suggested parameters or defaults if none
        RUN       Refmac

    # capture iteration number with the lowest Rfree achieved
    let iter0 = iter; Rfree0 = Rfree  if  Rfree<Rfree0
    let iter  = iter + 1

    # keep iterating if conditions are met and pass otherwise
    repeat @REFINE-OPT while suggested>0 and iter<5 

    # continue further down from iteration with the lowest Rfree
    branch @REFINE-OPT[iter0]

    #

    @PDBVAL
        RUN PDBVal
    #

.. note::
   Workflows with input parameters cannot be used in *Import* task and in the
   *CloudRun* utility.


-----------------------
Custom Workflow Library
-----------------------

CCP4 Cloud comes with a library of custom workflows, which give **WScript** 
examples for few typiucal scenarios. They can be also used as templates for
your own developments. Just open **Workflow Creator**, push **Library**
button and select a suitable **WScript**. It can be further modified to your
needs as any text file.


.. _wscript_reference:

-----------------
WScript Reference
-----------------

**WScript** file consists of four **sections**, which must follow order presented
in this Reference. Each section contains a specific set of **WScript** 
statements; no statement from one section can appear in another one. Section 
separators are not used; **WScript** recognises sections automatically. Only
:ref:`wscript_reference_input_parameters` can be empty.

All **WScript** **statements** occupy a single line. Statements start with a 
case-insensitive primary key, which may be followed by additional case-insensitive
key(s) and values. Any number of consequuitive spaces is equivalent to one space,
except when these spaces occur in string-type values. Part of line starting
from hash sign "#" is considered as a comment and is ignored; empty lines are
ignored, too.

Some **WScript** constructs are made of several statements, which must be
placed on consequitive lines (comments and empty lines ignored). Such constructs
have mandatory leading and trailing statements, other statements can be placed
in arbitrary order.

**WScript** supports pre-defined and user-defined variables, which can hold
real, integer, boolean and string values. String literals must be double-quoted
(*e.g.*, "this is a string literal"), boolean literals are case-sensitive
``True`` and ``False``. Pre-defined variables get their values from completed
tasks; see details in :ref:`wscript_reference_predefined_variables`.

Wherever variable's value is used, any in-line expression can be placed instead,
which may also include other variables; reference to variable's value should be
viewed as a computable trivial expression made of a single variable. See
available functions, constants and operators in
:ref:`wscript_reference_expression_syntax`.


~~~~~~~~~~~~~~
Header section
~~~~~~~~~~~~~~


~~~~~~~~~~~~~~~~~~
Input data section
~~~~~~~~~~~~~~~~~~


.. _wscript_reference_input_parameters:

~~~~~~~~~~~~~~~~~~~~~~~~
Input parameters section
~~~~~~~~~~~~~~~~~~~~~~~~



~~~~~~~~~~~~~~~~~~~~~
Workflow body section
~~~~~~~~~~~~~~~~~~~~~


.. _wscript_reference_predefined_variables:

~~~~~~~~~~~~~~~~~~~~~
Pre-defined variables
~~~~~~~~~~~~~~~~~~~~~



.. _wscript_reference_expression_syntax:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Mathematrical expressions syntax
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**WScript** allows almost full range of *Python* mathematical expressions in
*LET* statements and conditional statements. Available functions and operators 
are listed in this section.

.. list-table:: Operator precedence
   :widths: 15 15 70
   :header-rows: 1

   * - Operator
     - Associativity
     - Description
   * - (...)
     - None
     - Grouping
   * - f(), x.y, a[i]
     - Left
     - Function call, property access, array indexing
   * - !
     - Left
     - Factorial
   * - ^
     - Right
     - Exponentiation
   * - +, -, not, sqrt, etc.
     - Right
     - Unary prefix operators (see below for the full list)
   * - \*, /, %
     - Left
     - Multiplication, division, remainder
   * - +, -, \|\|               
     - Left
     - Addition, subtraction, array/list concatenation
   * - ==, !=, >=, <=, >, <, in 
     - Left
     - Equals, not equals, etc. "in" means "is the left operand included in the right array operand?"
   * - and
     - Left
     - Logical AND
   * - or
     - Left
     - Logical OR
   * - x ? y : z
     - Right
     - Ternary conditional (if x then y else z)
   * - =
     - Right
     - Variable assignment
   * - ;
     - Left
     - Expression separator


.. list-table:: Unary operators
   :widths: 15 85
   :header-rows: 1

   * - Operator
     - Description
   * - -x
     - Negation
   * - +x
     - Unary plus. This converts it's operand to a number, but has no other effect.
   * - x!
     - Factorial (x * (x-1) * (x-2) * … * 2 * 1). gamma(x + 1) for non-integers.
   * - abs x
     - Absolute value (magnitude) of x
   * - acos x
     - Arc cosine of x (in radians)
   * - acosh x
     - Hyperbolic arc cosine of x (in radians)
   * - asin x
     - Arc sine of x (in radians)
   * - asinh x
     - Hyperbolic arc sine of x (in radians)
   * - atan x
     - Arc tangent of x (in radians)
   * - atanh x
     - Hyperbolic arc tangent of x (in radians)
   * - cbrt x
     - Cube root of x
   * - ceil x
     - Ceiling of x — the smallest integer that’s >= x
   * - cos x
     - Cosine of x (x is in radians)
   * - cosh x
     - Hyperbolic cosine of x (x is in radians)
   * - exp x
     - e^x (exponential/antilogarithm function with base e)
   * - expm1 x
     - e^x - 1
   * - floor x
     - Floor of x — the largest integer that’s <= x
   * - length x
     - String or array length of x
   * - ln x
     - Natural logarithm of x
   * - log x
     - Natural logarithm of x (synonym for ln, not base-10)
   * - log10 x
     - Base-10 logarithm of x
   * - log2 x
     - Base-2 logarithm of x
   * - log1p x
     - Natural logarithm of (1 + x)
   * - not x
     - Logical NOT operator
   * - round x
     - X, rounded to the nearest integer, using "grade-school rounding"
   * - sign x
     - Sign of x (-1, 0, or 1 for negative, zero, or positive respectively)
   * - sin x
     - Sine of x (x is in radians)
   * - sinh x
     - Hyperbolic sine of x (x is in radians)
   * - sqrt x
     - Square root of x. Result is NaN (Not a Number) if x is negative.
   * - tan x
     - Tangent of x (x is in radians)
   * - tanh x
     - Hyperbolic tangent of x (x is in radians)
   * - trunc x
     - Integral part of a X, looks like floor(x) unless for negative number

.. list-table:: Pre-defined functions
   :widths: 17 83
   :header-rows: 1

   * - Function
     - Description
   * - random(n)
     - Get a random number in the range [0, n). If n is zero, or not provided, it defaults to 1.
   * - fac(n)
     - n! (factorial of n: "n * (n-1) * (n-2) * … * 2 * 1") Deprecated. Use the ! operator instead.
   * - min(a,b,…)
     - Get the smallest (minimum) number in the list.
   * - max(a,b,…)
     - Get the largest (maximum) number in the list.
   * - hypot(a,b)
     - Hypotenuse, i.e. the square root of the sum of squares of its arguments.
   * - pyt(a, b)
     - Alias for hypot.
   * - pow(x, y)
     - Equivalent to x^y. For consistency with JavaScript's Math object.
   * - atan2(y, x)
     - Arc tangent of x/y. i.e. the angle between (0, 0) and (x, y) in radians.
   * - roundTo(x, n)
     - Rounds x to n places after the decimal point.
   * - map(f, a)
     - Array map: Pass each element of `a` the function `f`, and return an array of the results.
   * - fold(f, y, a)
     - Array fold: Fold/reduce array `a` into a single value, `y` by setting `y = f(y, x, index)` for each element `x` of the array.
   * - filter(f, a)
     - Array filter: Return an array containing only the values from `a` where `f(x, index)` is `true`.
   * - indexOf(x, a)
     - Return the first index of string or array `a` matching the value `x`, or `-1` if not found.
   * - join(sep, a)
     - Concatenate the elements of `a`, separated by `sep`.
   * - if(c, a, b)
     - Function form of c ? a : b. Note: This always evaluates both `a` and `b`, regardless of whether `c` is `true` or not. Use `c ? a : b` instead if there are side effects, or if evaluating the branches could be expensive.


.. list-table:: Constants
   :widths: 15 85
   :header-rows: 1

   * - Constant
     - Description
   * - E
     - The value of `Math.E` from your JavaScript runtime
   * - PI
     - The value of `Math.PI` from your JavaScript runtime
   * - true
     - Logical `true` value
   * - false
     - Logical `false` value
